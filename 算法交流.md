
# 1.时间复杂度
> 时间复杂度就是计算那些常数语句O(1)的次数，它可以是比较次数，可以是递归次数，这个次数就是规模，表达的就是规模对时间的影响。

> 和同行交流中，虽然常数语句可能耗时不同（赋值和累加），电脑性能可能不同，但大致上在规模达到一定量级之后时间相差不多。比如跑1个累加，他10^8次方耗时1秒，
我10^7就耗时了1秒。知道这个大概，就可以在设计算法的时候，知道如果想要实现多长时间的响应需要哪个级别的时间复杂度。不过，说过了，常数语句不同耗时不同，
具体业务逻辑，耗时肯定比累加复杂，所以保险起见可以低估1个量级（比如除以10），来衡量自己计算机性能。

> 时间复杂度logn，其本质含义是把一个规模以某个底数去减少到1/0，logn就是规模减少了几次，也就是我们要的比较次数/递归次数。比如10个数，折半查找要多少次
等价于10除以2多少次会变成1/0，当然如果是我的话，直接估算在2^3,2^4之间，所以是3次多。但专业准确计算就是log2(10）。

> 递归的深度是消耗的“空间复杂度”，不是所有的递归都是nlogn，千万要具体情况具体分析，程序员可不能死记硬背。比如递归累加时间复杂度是n(只要加n次嘛）。
递归二分查找是logn（递归里只是简单判断这个值是不是target），归并排序是nlogn（递归里面还有个for循环）

# 2.算法交流过程中对代码的理解
> 如果别人提出了一种想法，你想了想觉得逻辑没有问题，没有遗漏，那么其实算法就是想法，接下来去看他的代码的时候不要老是怀疑“想法的正确性”，而应该关注
这行代码有没有“正确地表示”想法。

# 3.递归中有多次递归,递归次数是一个灾难级别
```java
  public int test(int n){
     if(n==0) return 1;
     int a = test(n-1);
     int b = test(n-1);
     return a+b;
  }
  和
  public int test(int n){
    if(n==0) return 1;
    return test(n-1)+test(n-1);
  }
```
>   递归次数不是简单的n+n-1，而是2^n-1次方，因为这次相当于二叉树的形成过程，每一层都在翻倍。如果认为只是test(n)到0的n次，加上另一个test(n)到0的n次，也就是2n-1次，那真的是漏算了很多，这个2n-1只在n=1/n=2恰巧符合，在规模为3的时候，只会算2-1-0,2-1-0，漏算了每个1下应该有两个2，想法不对，救不回来的，
  应该换成二叉树的形成过程才是"正确的想法"
