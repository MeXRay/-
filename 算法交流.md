
# 1.时间复杂度
> 时间复杂度就是计算那些常数语句O(1)的次数，它可以是比较次数，可以是递归次数，这个次数就是规模，表达的就是规模对时间的影响。

> 和同行交流中，虽然常数语句可能耗时不同（赋值和累加），电脑性能可能不同，但大致上在规模达到一定量级之后时间相差不多。比如跑1个累加，他10^8次方耗时1秒，
我10^7就耗时了1秒。知道这个大概，就可以在设计算法的时候，知道如果想要实现多长时间的响应需要哪个级别的时间复杂度。不过，说过了，常数语句不同耗时不同，
具体业务逻辑，耗时肯定比累加复杂，所以保险起见可以低估1个量级（比如除以10），来衡量自己计算机性能。

> 时间复杂度logn，其本质含义是把一个规模以某个底数去减少到1/0，logn就是规模减少了几次，也就是我们要的比较次数/递归次数。比如10个数，折半查找要多少次
等价于10除以2多少次会变成1/0，当然如果是我的话，直接估算在2^3,2^4之间，所以是3次多。但专业准确计算就是log2(10）。

> 递归的深度是消耗的“空间复杂度”，不是所有的递归都是nlogn，千万要具体情况具体分析，程序员可不能死记硬背。比如递归累加时间复杂度是n(只要加n次嘛）。
递归二分查找是logn（递归里只是简单判断这个值是不是target），归并排序是nlogn（递归里面还有个for循环）

# 2.算法交流过程中对代码的理解
> 如果别人提出了一种想法，你想了想觉得逻辑没有问题，没有遗漏，那么其实算法就是想法，接下来去看他的代码的时候不要老是怀疑“想法的正确性”，而应该关注
这行代码有没有“正确地表示”想法。

# 3.递归中有多次递归,递归次数是一个灾难级别
```java
  public int test(int n){
     if(n==0) return 1;
     int a = test(n-1);
     int b = test(n-1);
     return a+b;
  }
  和
  public int test(int n){
    if(n==0) return 1;
    return test(n-1)+test(n-1);
  }
```
>   递归次数不是简单的n+n-1，而是2^n-1次方，因为这次相当于二叉树的形成过程，每一层都在翻倍。如果认为只是test(n)到0的n次，加上另一个test(n)到0的n次，也就是2n-1次，那真的是漏算了很多，这个2n-1只在n=1/n=2恰巧符合，在规模为3的时候，只会算2-1-0,2-1-0，漏算了每个1下应该有两个2，想法不对，救不回来的，
  应该换成二叉树的形成过程才是"正确的想法"

# 4.均摊复杂度分析
> 所谓均摊，指的是具有动态扩容能力的方法，比如ArrayList这些，它在添加/删除的时候，在不需要扩容的时候所需要的时间复杂度是O(1）,而在需要扩容的时候，它需要搬运之前的数组，所以时间复杂度是O（n），但从整体上来看，这个扩容不是时刻发生的，所以O(n）可以看成和前面那些个O(1）一起算，也就是n+1个数，时间复杂度为O(n），这样看起来，平均每一个还是O(1)
> 减容也是这样的操作，只是，有一种危险的情况就是加了1个扩容，减了1个减容，不断重复这个临界点会让复杂度“震荡”,让复杂度变成每一个都是O(n)，所以看源码可以知道，把减容的临界点设置为size/4，扩容则是长度==size；原理是如果把减容的临界点设置为size/2，会有这种情况：下一个加进来一定会导致扩容，而用size/4，还有size/4~size/2这个缓冲区来不频繁扩容

