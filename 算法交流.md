
# 1.时间复杂度
> 时间复杂度就是计算那些常数语句O(1)的次数，它可以是比较次数，可以是递归次数，这个次数就是规模，表达的就是规模对时间的影响。

> 和同行交流中，虽然常数语句可能耗时不同（赋值和累加），电脑性能可能不同，但大致上在规模达到一定量级之后时间相差不多。比如跑1个累加，他10^8次方耗时1秒，
我10^7就耗时了1秒。知道这个大概，就可以在设计算法的时候，知道如果想要实现多长时间的响应需要哪个级别的时间复杂度。不过，说过了，常数语句不同耗时不同，
具体业务逻辑，耗时肯定比累加复杂，所以保险起见可以低估1个量级（比如除以10），来衡量自己计算机性能。

> 时间复杂度logn，其本质含义是把一个规模以某个底数去减少到1/0，logn就是规模减少了几次，也就是我们要的比较次数/递归次数。比如10个数，折半查找要多少次
等价于10除以2多少次会变成1/0，当然如果是我的话，直接估算在2^3,2^4之间，所以是3次多。但专业准确计算就是log2(10）。

> 递归的深度是消耗的“空间复杂度”，不是所有的递归都是nlogn，千万要具体情况具体分析，程序员可不能死记硬背。比如递归累加时间复杂度是n(只要加n次嘛）。
递归二分查找是logn（递归里只是简单判断这个值是不是target），归并排序是nlogn（递归里面还有个for循环）

# 2.算法交流过程中对代码的理解
> 如果别人提出了一种想法，你想了想觉得逻辑没有问题，没有遗漏，那么其实算法就是想法，接下来去看他的代码的时候不要老是怀疑“想法的正确性”，而应该关注
这行代码有没有“正确地表示”想法。

# 3.递归中有多次递归,递归次数是一个灾难级别
```java
  public int test(int n){
     if(n==0) return 1;
     int a = test(n-1);
     int b = test(n-1);
     return a+b;
  }
  和
  public int test(int n){
    if(n==0) return 1;
    return test(n-1)+test(n-1);
  }
```
>   递归次数不是简单的n+n-1，而是2^n-1次方，因为这次相当于二叉树的形成过程，每一层都在翻倍。如果认为只是test(n)到0的n次，加上另一个test(n)到0的n次，也就是2n-1次，那真的是漏算了很多，这个2n-1只在n=1/n=2恰巧符合，在规模为3的时候，只会算2-1-0,2-1-0，漏算了每个1下应该有两个2，想法不对，救不回来的，
  应该换成二叉树的形成过程才是"正确的想法"

# 4.均摊复杂度分析
> 所谓均摊，指的是具有动态扩容能力的方法，比如ArrayList这些，它在添加/删除的时候，在不需要扩容的时候所需要的时间复杂度是O(1）,而在需要扩容的时候，它需要搬运之前的数组，所以时间复杂度是O（n），但从整体上来看，这个扩容不是时刻发生的，所以O(n）可以看成和前面那些个O(1）一起算，也就是n+1个数，时间复杂度为O(n），这样看起来，平均每一个还是O(1)
> 减容也是这样的操作，只是，有一种危险的情况就是加了1个扩容，减了1个减容，不断重复这个临界点会让复杂度“震荡”,让复杂度变成每一个都是O(n)，所以看源码可以知道，把减容的临界点设置为size/4，扩容则是长度==size；原理是如果把减容的临界点设置为size/2，会有这种情况：下一个加进来一定会导致扩容，而用size/4，还有size/4~size/2这个缓冲区来不频繁扩容

# 5.编写程序的时候关于边界，应该是<还是<=,应该+1，还是不用
> 在讨论循环退出或是折半的时候，有时候思路很明确，但在写的时候会卡带，常常因为计算机是从0开始算的而和现实有些许不同而犹豫，虽然到了这级别其实已经把0和长度-1作为开始和结束，熟记于心，但不可避免仍然有所卡带。
> 同行说关键是理解变量的定义，这里好笑的是，我其实很多时候都是基于以前写的/看的边界，就那么不假思索地写，大不了调试1下，我都是这样过来的，也一直没多大毛病。同行说起一个笑话，说二分查找法一开始有个Bug，隔了16年才发现这个bug和才把它改正。我笑了笑，觉得这样看来自己的“运气”还是有期限的。所以既然碰上了，就和他一起补上这个bug。
> 所以以这个二分查找为例子，讨论了右边界取了长度和长度-1两种情况下，对于代码的改动
  while(l<=r）:当r取长度-1,意味着这是个上闭下闭的区间，【0，len-1】，len-1可取。这是它的变量含义，所以在l=r的时候，比如[3,3]，那么3这个位置的值
  会不会就是我们要找的那个值，当然，漏算了它，可能就和答案失之交臂了。所以l<=r!
  当目标比中间值大：左边界应该更新 l=mid+1
  当目标比中间值小：右边界：r=mid-1   这里的mid都是在比较的时候已经比过了，所以才会被两种情况忽略！
  和
 
> while(l<r):当r取长度时，【3,3）,如果你不从变量的定义入手，任然会觉得mid=(3+3)/2=3,中间值有取的必要；那么我们来看看当目标值不等于中间值的情况
   当目标比中间值大：左边界应该更新 l=mid+1 
  当目标比中间值小： 右边界 r=mid-1;
  这个时候在l=3,r=3的时候，进来了也会去判断3这个位置的值，也会去更新边界退出循环，没什么大影响（我就是这样。。）但是比如【0,3),[3,6)，这个值在【3,6）已经比过了要退出早退出了，这一步是浪费。作为程序员任何能省的不应该给计算机负担，这在计算机世界相当于它在百米赛跑让了50米那样不公平！
  所以把while退出是l<r，那么在做出这个改动，左右边界的更新是否需要变动，这个时候要意识到这是个下闭上开，就不用这么麻烦地还去举例子来看。就可以这么
  分析，下闭上开意味着【3，3)取不到：l<r; 取不到意味着边界不能忽略这个位置的值，下闭上开，可以有两种改法，你想让这个中间值归到左还是右，计算机常常向下取整，那我们就归到左边，左边要囊括中间值，右边界就得r=mid,因为这个mid是在一开始就是取大了1，r取长度，取了一个拿不到的数，这个影响看看，都影响到每个数的复杂考虑，真是不该乱取边界啊！

> 上面讲了很多，看起来会乱，因为“例子”被用来验证想法的正确性了，而这个区间的想法是含义、本质，他没有错，如果“例子”是用来“说明”想法的正确性，直接从含义入手，不用举例子都可以让你早点明白了。

> 而那个16年的bug，来源于中间值mid=(l+r)/2;其实存在l+r溢出的问题，明明要个中间值还溢出，这个时候可以mid=l+(r-l)/2;开始加上一半，这样就完美了！

6. leetcode283,移动0的时间O(n)，空间O(1）解法
> Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
> 思路：只要从头遍历，把每一个非0数和“第一个0”交换就行，不想浪费时间就遍历找第一个0,就在遍历的过程中一遍找，找到了第一个0就停下来，等待找下一个“非0数”，这样我们就需要一个记录0的索引（int index,比起开一个O(n)的数组空间绝对划算）。有可能有几个0连在一起，也有可能没有怎么办：观察得出规律-----011和00011：011-》101，下一个index应该是1；    “0”0011-》100“0”1，下一个index应该是1。  所以无论有没有0连着，只要把index++就行，这样index要么指向唯一的0；要么指向下一个0。
```java
   public void moveZeroes(int[] nums) {
        int replaceIndex = 0;//可以替换的位置，可以替换的只能是0
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=0) {
                  if(i!=replaceIndex)//相等的时候,说明还没找到第一个0
                {
                    int tmp= nums[replaceIndex];
                    nums[replaceIndex]=nums[i];
                    nums[i]=tmp;
                }
              replaceIndex++;//每次非0，它都要+，因为还没找到0，找到了它会在和非0数交换才加，这意味着这期间可能有几个0连着，但是因为没进这个循环
              //维持在第一个0位置
            }
        }     
    }
```




